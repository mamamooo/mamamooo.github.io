<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaMaMoo</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mamamooo.github.io/"/>
  <updated>2020-04-09T06:03:33.222Z</updated>
  <id>https://mamamooo.github.io/</id>
  
  <author>
    <name>mamamooo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协程</title>
    <link href="https://mamamooo.github.io/2020/04/09/Corout/"/>
    <id>https://mamamooo.github.io/2020/04/09/Corout/</id>
    <published>2020-04-09T02:53:58.000Z</published>
    <updated>2020-04-09T06:03:33.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a><strong>什么是协程</strong></h2><p>协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p><a id="more"></a> <p><img src="https://raw.githubusercontent.com/mamamooo/mamamooo.github.io/master/2020/04/09/Corout/clipboard.png" alt="img"></p><ul><li>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</li><li>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</li><li>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是串行的。如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须挂起。</li></ul><h2 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a><strong>进程、线程、协程的对比</strong></h2><ul><li>协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。</li><li>一个进程可以包含多个线程，一个线程可以包含多个协程。</li><li>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</li><li>协程与进程一样，切换是存在上下文切换问题的。<ul><li>进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。</li><li>线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</li><li>协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。</li></ul></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><p><img src="/.io//E:%5Cgithub%5Cmamamoo%5Csource_posts%5CCorout%5Cclipboard-1586401534592-1586412131949.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r &#x3D; &#39;&#39;</span><br><span class="line">    while True:</span><br><span class="line">        n &#x3D; yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&#39;[CONSUMER] Consuming %s...&#39; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r &#x3D; &#39;200 OK&#39;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;[PRODUCER] Producing %s...&#39; % n)</span><br><span class="line">        r &#x3D; c.send(n)</span><br><span class="line">        print(&#39;[PRODUCER] Consumer return: %s&#39; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    c &#x3D; consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p><p>首先调用c.next()启动生成器；</p><p>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</p><p>consumer通过yield拿到消息，处理，又通过yield把结果传回；</p><p>produce拿到consumer处理的结果，继续生产下一条消息；</p><p>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</p><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。</p><p>yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是协程&quot;&gt;&lt;a href=&quot;#什么是协程&quot; class=&quot;headerlink&quot; title=&quot;什么是协程&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是协程&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://mamamooo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python map() 函数</title>
    <link href="https://mamamooo.github.io/2020/04/08/py1/"/>
    <id>https://mamamooo.github.io/2020/04/08/py1/</id>
    <published>2020-04-08T03:05:14.000Z</published>
    <updated>2020-04-08T03:15:17.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><a id="more"></a> <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>map() 函数语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>function – 函数</li><li>iterable – 一个或多个序列</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Python 2.x 返回列表。</p><p>Python 3.x 返回迭代器。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下实例展示了 map() 的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\&gt;&gt;&gt;def square(x) :            # 计算平方数 </span><br><span class="line">...     return x ** 2 ...  </span><br><span class="line">&gt;&gt;&gt; map(square, [1,2,3,4,5])   # 计算列表各个元素的平方 [1, 4, 9, 16, 25] </span><br><span class="line">&gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数</span><br><span class="line">[1, 4, 9, 16, 25] </span><br><span class="line"></span><br><span class="line"># 提供了两个列表，对相同位置的列表数据进行相加 </span><br><span class="line">&gt;&gt;&gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">将一个罗马数字转化为阿拉伯数字，范围在1-3999。下面是罗马数字的介绍及基本规则：</span><br><span class="line">罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def RomaToInt(self,s):</span><br><span class="line">        map &#x3D; &#123;&quot;M&quot;:1000, &quot;D&quot;:500,&quot;C&quot;:100, &quot;L&quot;:50, &quot;X&quot;:10,&quot;V&quot;:5,&quot;I&quot;:1&#125;</span><br><span class="line">        result &#x3D; 0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">          if i &gt; 0 and map[s[i]] &gt; map[s[i-1]]:</span><br><span class="line">              result -&#x3D; map[s[i-1]]</span><br><span class="line">              result +&#x3D; map[s[i]] - map[s[i-1]]</span><br><span class="line">          else:</span><br><span class="line">              result +&#x3D; map[s[i]]</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print (Solution().RomaToInt(&quot;XII&quot;))</span><br><span class="line">    print(Solution().RomaToInt(&quot;XXI&quot;) )</span><br><span class="line">    print( Solution().RomaToInt(&quot;XCI&quot;) )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;map()&lt;/strong&gt; 会根据提供的函数对指定序列做映射。&lt;/p&gt;
&lt;p&gt;第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>stx-gui</title>
    <link href="https://mamamooo.github.io/2020/03/16/stx-gui/"/>
    <id>https://mamamooo.github.io/2020/03/16/stx-gui/</id>
    <published>2020-03-16T03:06:31.000Z</published>
    <updated>2020-03-16T05:27:17.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StarlingX-GUI-源码分析"><a href="#StarlingX-GUI-源码分析" class="headerlink" title="StarlingX GUI 源码分析"></a>StarlingX GUI 源码分析</h1><p>代码架构<br>GUI部分代码主要为starlingX dashboard的代码，主要功能为界面的操作和底层其他组件（Nova，Neutron，Cinder等）的交互。代码架构为Django框架。</p><a id="more"></a> <p>Django是一个基于Python的高效的Web开发框架，它提供了通用的Web开发模式的高度抽象；目的是为了可以简便的、快速的开发数据库驱动的网站，强调代码的复用，多个组件可以很方便的以“插件”的形式存在于整个框架中。</p><p>代码目录如图</p><h1 id="代码目录分析"><a href="#代码目录分析" class="headerlink" title="代码目录分析"></a>代码目录分析</h1><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>主要是与其他组件的api接口代码</p><h2 id="Dashboards"><a href="#Dashboards" class="headerlink" title="Dashboards"></a>Dashboards</h2><p>主要负责后端逻辑。如登录页面，添加节点等操作</p><h2 id="Enabled"><a href="#Enabled" class="headerlink" title="Enabled"></a>Enabled</h2><p>新增plane模块的注册配置，此处代码的主要功能是面板组的定义。</p><h2 id="Horizon"><a href="#Horizon" class="headerlink" title="Horizon"></a>Horizon</h2><p>主要提供最基础的构件，如页面所需的表格、表单等基础部分；</p><h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>主要存放前端代码。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="Dashboards模块"><a href="#Dashboards模块" class="headerlink" title="Dashboards模块"></a>Dashboards模块</h2><h3 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h3><p>此部分代码包括<br>active_alarms<br>controller_services<br>datanets<br>events<br>events_suppression<br>host_topology<br>inventory<br>software_management<br>storage_overview<br>system_config<br>10个小模块，对应的页面的各自功能。<br>页面图待补</p><p>代码流程，此处以inventory为例讲解：<br>Inventory  主要功能是节点的增删改查操作，主要与底层的sysinv模块交互。</p><p>####1. 注册plane ####</p><p>首先在enabled目录下注册inventory模块的plane,<br>即starlingx_dashboard/enabled/_2035_starlingx_admin_inventory_panel.py文件</p><p>ADD_PANEL = ‘starlingx_dashboard.dashboards.admin.inventory.panel.Inventory’<br>此处为class Inventory的位置</p><p>####2.    Inventory类 ####<br>Inventory类位于starlingx_dashboard/dashboards/admin/inventory/panel.py文件下:</p><pre><code>class Inventory(horizon.Panel):        #面板类       name = _("Host Inventory")        #面板名字    slug = 'inventory'            #面板短名字（面板url路径的短名字）Slug会为每条model记录    permissions = ('openstack.roles.admin',)    permissions = ('openstack.services.platform',)   #权限名称列表，定义了用户是否有权限访问该面板    def allowed(self, context):       ……    def nav(self, context):        #导航条，判断该面板是否出现导航        ……</code></pre><p>####3.    页面功能管理 ####<br>starlingx_dashboard/dashboards/admin/inventory/tables.py文件下主要为各个页面的功能的class。如Hosts，HostsController以及他的子功能AddHost，EditHost，DeleteHost等。</p><p>首先分析class Hosts：</p><pre><code>class Hosts(tables.DataTable):    hostname = tables.Column('hostname',                             link="horizon:admin:inventory:detail",                             verbose_name=_('Host Name'))    personality = tables.Column(        "personality",        verbose_name=_("Personality"),        display_choices=stx_api.sysinv.Host.PERSONALITY_DISPLAY_CHOICES)    admin = tables.Column("administrative",                          verbose_name=_("Admin State"),                          display_choices=stx_api.sysinv.                          Host.ADMIN_DISPLAY_CHOICES)    oper = tables.Column("operational",                         verbose_name=_("Operational State"),                         display_choices=stx_api.sysinv.                         Host.OPER_DISPLAY_CHOICES)    avail = tables.Column("availability",                          verbose_name=_("Availability State"),                          display_choices=stx_api.sysinv.                          Host.AVAIL_DISPLAY_CHOICES)    uptime = tables.Column('boottime',                           verbose_name=_("Uptime"),                           filters=(filters.timesince_sortable,),                           attrs={'data-type': 'timesince'})    task = tables.Column(get_task_or_status,                         cell_attributes_getter=get_install_percent,                         verbose_name=_("Status"),                         filters=(safe,),                         status=True,                         status_choices=TASK_STATE_CHOICES)    def get_object_id(self, datum):        return str(datum.id)    def get_object_display(self, datum):        return datum.hostname</code></pre><p>通过tables.Column接口，会在界面上生成相应的表单，如hostname，personality 等。</p><p>HostsController类，控制节点的视图。HostsStorage类，HostsWorker类分别为存储和计算节点的视图类，主要包括增删改查的类，通过row_actions添加。<br><code><pre><br>class HostsController(Hosts):<br>    class Meta(object):<br>        name = "hostscontroller"<br>        verbose_name = _("Controller Hosts")<br>        status_columns = ["task"]<br>        row_class = UpdateRow<br>        multi_select = True<br>        row_actions = (<br>            EditHost, LockHost, ForceLockHost, UnlockHost, ForceUnlockHost,<br>            SwactHost,<br>            PowerOnHost,<br>            PowerOffHost, RebootHost,<br>            ResetHost, ReinstallHost, PatchInstallAsync, DeleteHost)<br>        table_actions = (AddHost,)<br>        hidden_title = False<br></pre></code><br>增删改查等功能的这些类都比较近似，主要是通过各自的handle（）方法来处理的，以DeleteHost类为例。<br><code><pre><br>class DeleteHost(tables.DeleteAction):<br>    ……<br>    def delete(self, request, host_id):<br>        stx_api.sysinv.host_delete(request, host_id)<br>    def handle(self, table, request, obj_ids):<br>        return handle_sysinv(self, table, request, obj_ids)<br></pre></code></p><p>当用户点击删除按钮时，会触发handle接口，从而在调用delete接口，delete调用sysinv的api通过cgts将请求发送给sysinv模块，sysinv删除节点</p><p>####4.    Tab页面管理 ####<br>starlingx_dashboard/dashboards/admin/inventory/tabs.py文件主要为各个tab页的类。<br>主要包括HostsTab，CpuProfilesTab，InterfaceProfilesTab，主要功能是获取环境的信息并按照一定的格式显示。<br>如HostsTab类：<br><code><pre><br>class HostsTab(tabs.TableTab):<br>    table_classes = (toplevel_tables.HostsController,<br>                     toplevel_tables.HostsStorage,<br>                     toplevel_tables.HostsWorker,<br>                     toplevel_tables.HostsUnProvisioned,)<br>      #此处四种类型的hosts节点的表<br>    template_name = ("admin/inventory/_hosts.html")<br>    #前端html页面<br>    通过接口获取所有节点信息，主要是通过下发api的方式获取，如：<br>    def get_all_hosts_data(self):<br>       ... ...<br>    stx_api.sysinv.host_list<br>    ... ...<br>    处理数据并以一定的格式显示数据到HTML上<br>    def load_table_data(self):<br>    ... ...<br>    def get_context_data(self, request):<br></pre></code><br>####5.     urls路由 ####</p><p>starlingx_dashboard/dashboards/admin/inventory/urls.py，此文件中为相关的路由，写在一起方便调用。</p><p>####6.    Views ####<br>starlingx_dashboard/dashboards/admin/inventory/views.py，为视图文件</p><p>####7.    Workflows ####<br>starlingx_dashboard/dashboards/admin/inventory/workflows.py，主要是AddHost和UpdateHost工作流程</p><p>以AddHost为例，<br><code><pre><br>class AddHost(workflows.Workflow):<br>    slug = "add"<br>    name = _("Add Host")<br>... ...<br>    def handle(self, request, data):<br>        self.hostname = data['hostname']<br>        self.mgmt_mac = data['mgmt_mac']<br>        try:<br>            host = stx_api.sysinv.host_create(request, **data)<br>            return True if host else False<br>        except exc.ClientException as ce:<br>            # Display REST API error on the GUI<br>            LOG.error(ce)<br>            msg = self.failure_message + " " + str(ce)<br>            self.failure_message = msg<br>            return False<br>        except Exception as e:<br>            msg = self.format_status_message(self.failure_message) + str(e)<br>            exceptions.handle(request, msg)<br>            return False<br></pre></code><br>主要是前台触发按钮后进入handle接口处理，将数据下发给sysinv模块，sysinv再根据数据添加节点。</p><p>Admin目录下还有active_alarms，controller_services，datanets，events，events_suppression，host_topology，inventory，software_management，storage_overview<br>，system_config等功能，他们都采用了统一Django架构，以及统一的代码风格，不同的模块之间可以相互参考。此处不再一一分析。</p><h3 id="DcAdmin"><a href="#DcAdmin" class="headerlink" title="DcAdmin"></a>DcAdmin</h3><p>此处为OpenStack多Region管理页面。</p><p>所谓openstack多region，就是多套openstack共享一个keystone和horizon。每个区域一套openstack环境，可以分布在不同的地理位置，只要网络可达就行。个人认为目的就是为了提供环境隔离的功能，选择启虚拟机的时候可以根据自己所处的位置就近选择。</p><p>目录：</p><p>主要包括管理页面显示，以及多region的软件管理功能。</p><h2 id="Api模块"><a href="#Api模块" class="headerlink" title="Api模块"></a>Api模块</h2><p>此部分内容主要包括”base”,”ceph”,”dc_manager”,”fm”,”neutron”,”patch”,”sysinv”,”vim”,<br>8部分的api接口，分别在不同的名称对应文件中方便管理。</p><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>starlingx_dashboard/api/base.py<br>此处、主要导入了开源的base接口<br>from openstack_dashboard.api import base</p><p>同时添加了两个公共接口，get_request_page_size（判断请求长度），is_stx_region（判断platform服务是否正常）</p><h3 id="ceph"><a href="#ceph" class="headerlink" title="ceph"></a>ceph</h3><p>主要实现了前台与底层ceph模块的交互<br>导入wrapper模块<br>from cephclient import wrapper</p><p>定义ceph模块的类如OSD，Cluster，Storage<br>以及处理函数cluster_get，storage_get _get_quorum_status，monitor_list，osd_list等，通过cephwrapper()进行与ceph后台模块的交互</p><p>如monitor_list接口：<br>在admin 的StorageServicesTab页面，需要显示storage_services的一些信息，通过调用get_monitors_data接口，调用到ceph.monitor_list，然后monitor_list通过cephwrapper接口将请求下发到ceph后台，请求成功后返回response<br>，再在monitor_list解析返回数据，返回给get_monitors_data接口。</p><h3 id="dc-manager"><a href="#dc-manager" class="headerlink" title="dc_manager"></a>dc_manager</h3><p>主要实现了前台与底层dc_manager模块的交互<br>导入交互需要的client模块<br>from dcmanagerclient.api.v1 import client<br>dcmanagerclient方法为将原有的client进行封装。</p><p>此部分的主要接口有，<br>获取告警的alarm_summary_list接口<br>获取子cloud信息的subcloud_list接口<br>增加子cloud信息的subcloud_create接口<br>删除子cloud信息的subcloud_delete接口<br>修改子cloud信息的subcloud_update接口<br>配置子cloud信息的subcloud_generate_config接口</p><p>软件升级策略的类Strategy及其相关的软件升级接口</p><h3 id="fm"><a href="#fm" class="headerlink" title="fm"></a>fm</h3><p>主要实现了前台与底层fm告警模块的交互</p><p>主要流程为用户触发告警页面的功能后，此部分模块通过fmclient接口，与底层的fm模块进行数据交互</p><h3 id="iservice"><a href="#iservice" class="headerlink" title="iservice"></a>iservice</h3><p>主要实现了前台与底层sm模块的交互<br>有两个接口<br>sm_sda_list 用于获取控制节点磁盘的信息<br>sm_nodes_list 用于获取节点信息<br>Neutron<br>主要实现了前台与底层Neutron网络模块的交互。<br>此处主要是添加了Providernet的api和qos的api组件。</p><p>包括<br>Providernet的接口：<br><code><pre><br>provider_network_type_list<br>provider_network_create<br>provider_network_list<br>provider_network_list_for_tenant<br>provider_network_list_tenant_networks<br>provider_network_get<br>provider_network_delete<br>provider_network_modify<br>provider_network_range_create<br>provider_network_range_list<br>provider_network_range_get<br>provider_network_range_delete<br>provider_network_range_modify<br></pre></code><br>和qos的接口：<br><code><pre><br>qos_list<br>qos_get<br>qos_create<br>qos_update<br></pre></code></p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>主要实现了前台与底层patch模块的交互。url基本为url += “/patch/%s” % (api_cmd)</p><p>在这部分代码，定义了新的client类<br>class Client(object)，它的方法有patch的get，show，upload，apply，remove以及相关节点的host_install，host_install_async操作</p><p>apply patch在dashboard的流程</p><h3 id="sysinv"><a href="#sysinv" class="headerlink" title="sysinv"></a>sysinv</h3><p>主要实现了前台与底层sysinv模块的交互，主要功能是操作host节点的增删改查。</p><p>Cgtsclient主要是重新封装了cgts_client的接口，用于下发api。<br>主要的接口对应页面的内容可以分为以下几类：</p><ol><li>Host<br>主要有host信息查询的personality，boottime，patch_state，host操作的host_create，host_update，host_delete，host_lock，host_force_lock，host_unlock，host_reboot，host_swact等等。<br>此处调用大体是一致的，以host_swact为例：</li></ol><p>stx_api.sysinv.host_swact(request, host_id)<br>首先，调用host_swact接口<br><code><pre><br>def host_swact(request, host_id):<br>    kwargs = {'action': 'swact'}<br>    host = host_update(request, host_id, *<em>kwargs)<br>    return host<br></em></pre></code><br>   api部分拼接swact的参数，再传参到update接口，<br><code><pre><br>def host_update(request, host_id, *kwargs):<br>    LOG.debug("host_update(): host_id=%s, kwargs=%s", host_id, kwargs)<br>    mypatch = []<br>    for key, value in kwargs.items():<br>        mypatch.append(dict(path='/' + key, value=value, op='replace'))<br>    return cgtsclient(request).ihost.update(host_id, mypatch)<br></pre></code><br>   在update过程中，继续拼接至完整的api的 ulr字符串，再由cgtsclient下发到后台处理。</p><p>host_label_get，host_label_assign，host_label_remove等，功能是为host添加标签。</p><ol start="2"><li>网络<br>主要包括Interface， Network， Port，SDNController等<br>Interface<br><code><pre><br>host_interface_list<br>host_interface_get<br>host_interface_create<br>host_interface_update<br>host_interface_delete<br></pre></code><br>Network<br><code><pre><br>network_list<br>network_get<br>network_create<br>network_delete<br></pre></code><br>InterfaceNetwork<br><code><pre><br>interface_network_list_by_interface<br>interface_network_get<br></pre></code><br>Port<br><code><pre><br>get_port_display_name<br></pre></code><br>SDNController<br><code><pre><br>sdn_controller_list<br>sdn_controller_get<br>sdn_controller_create<br>sdn_controller_update<br>sdn_controller_delete<br></pre></code></li></ol><p>###3.    存储 ###<br>主要包括Disk的物理信息，ceph的配置信息，以及storage的配置信息等接口。</p><p>###4.    其他信息 ###<br>此外，还有一些其他信息的接口如，ntp，lldp等信息</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>主要实现了前台与底层patch模块中升级策略strategy的交互，主要功能为补丁的策略升级和版本升级。</p><p>文件中导入的client的类<br>from nfv_client.openstack import sw_update<br>STRATEGY_SW_PATCH = ‘sw-patch’<br>STRATEGY_SW_UPGRADE = ‘sw-upgrade’</p><p>此部分代码主要流程相似，以create_strategy为例。<br>create_strategy的流程</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>此部分主要分析主题开发过程的逻辑。</p><h3 id="1-主题配置文件"><a href="#1-主题配置文件" class="headerlink" title="1.    主题配置文件"></a>1.    主题配置文件</h3><p>starlingx_dashboard/local/local_settings.d/_30_stx_local_settings.py<br>此文件主要涵盖了主题文件的路径，配置，以及时区配置<br><code><pre><br>AVAILABLE_THEMES = [<br>    ('default', 'Default', 'themes/default'),<br>    ('material', 'Material', 'themes/material'),<br>    ('starlingx', 'StarlingX', 'themes/starlingx'),<br>]<br>DEFAULT_THEME = 'starlingx'<br></pre></code><br>从这部分代码，可以分析，我们如果要添加新的主题，需要在此处更新，并将DEFAULT_THEME改成我们需要的。<br><code><pre><br>for root, _dirs, files in os.walk('/opt/branding/applied'):<br>    if 'manifest.py' in files:<br>        with open(os.path.join(root, 'manifest.py')) as f:<br>            code = compile(f.read(), os.path.join(root, 'manifest.py'), 'exec')<br>            exec(code)</pre></code></p><pre><code>AVAILABLE_THEMES = [    (&apos;default&apos;, &apos;Default&apos;, &apos;themes/default&apos;),    (&apos;material&apos;, &apos;Material&apos;, &apos;themes/material&apos;),    (&apos;starlingx&apos;, &apos;StarlingX&apos;, &apos;themes/starlingx&apos;),    (&apos;custom&apos;, &apos;Custom&apos;, &apos;/opt/branding/applied&apos;),]DEFAULT_THEME = &apos;custom&apos;</code></pre><p>STATIC_ROOT = "/www/pages/static"<br>COMPRESS_OFFLINE = True<br><br>此部分代码中，可以看出’starlingx’主题的文件路径位于themes/starlingx目录。</p><h3 id="2．主题文件themes-starlingx"><a href="#2．主题文件themes-starlingx" class="headerlink" title="2．主题文件themes/starlingx"></a>2．主题文件themes/starlingx</h3><p>此部分文件主要是前台的html和css文件，一般 修改主题，不会大规模的修改html的样式，我们一般只是更换厂商的logo，修改平台名称等。<br>Logo文件位于starlingx_dashboard/themes/starlingx/static/img目录</p><p>logo-splash.svg 是登录界面的大logo，更换时替换自己的svg图片。<br>logo.png主页面左上的brand图片，注意大小即可。<br>此外，可以根据不同的风格修改前端代码进行定制开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StarlingX-GUI-源码分析&quot;&gt;&lt;a href=&quot;#StarlingX-GUI-源码分析&quot; class=&quot;headerlink&quot; title=&quot;StarlingX GUI 源码分析&quot;&gt;&lt;/a&gt;StarlingX GUI 源码分析&lt;/h1&gt;&lt;p&gt;代码架构&lt;br&gt;GUI部分代码主要为starlingX dashboard的代码，主要功能为界面的操作和底层其他组件（Nova，Neutron，Cinder等）的交互。代码架构为Django框架。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stx" scheme="https://mamamooo.github.io/tags/stx/"/>
    
  </entry>
  
  <entry>
    <title>Hallo Mamamoo</title>
    <link href="https://mamamooo.github.io/2020/03/14/ceshi/"/>
    <id>https://mamamooo.github.io/2020/03/14/ceshi/</id>
    <published>2020-03-14T08:48:42.000Z</published>
    <updated>2020-03-16T05:15:07.977Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/mamamooo/mamamooo.github.io/master/2020/03/14/ceshi/mamamoo.jpg" alt="mamamoo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mamamooo/mamamooo.github.io/master/2020/03/14/ceshi/mamamoo.jpg&quot; alt=&quot;mamamoo&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
